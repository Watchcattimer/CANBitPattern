<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAN Bit Pattern Generator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for bit display */
        .bit-container {
            display: inline-flex;
            flex-wrap: wrap; /* Allow bits to wrap to the next line */
            gap: 2px; /* Small gap between bits */
            margin-bottom: 8px; /* Space below each field group */
        }
        .bit {
            font-family: 'Inter', sans-serif;
            font-size: 0.875rem; /* text-sm */
            font-weight: 600; /* font-semibold */
            padding: 2px 4px; /* px-1 py-0.5 */
            border-radius: 4px; /* rounded */
            min-width: 20px; /* Ensure a minimum width for single bits */
            text-align: center;
            display: inline-flex; /* Use flex to center content */
            align-items: center;
            justify-content: center;
        }
        .dominant {
            background-color: #3b82f6; /* blue-500 */
            color: white;
        }
        .recessive {
            background-color: #9ca3af; /* gray-400 */
            color: black;
        }
        .stuff-bit {
            outline: 2px solid #ef4444; /* red-500 outline for "red box" effect */
            outline-offset: 1px; /* Small offset for the outline */
        }
        .field-label {
            font-weight: 700; /* font-bold */
            margin-top: 10px;
            margin-bottom: 5px;
            display: block; /* Make label take full width */
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 8px;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-4xl">
        <h1 class="text-3xl font-bold text-center mb-6 text-gray-800">CAN Bit Pattern Generator</h1>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            <!-- Input Section -->
            <div class="space-y-4">
                <div>
                    <label for="canId" class="block text-sm font-medium text-gray-700">CAN ID (11-bit Hex):</label>
                    <input type="text" id="canId" value="123" maxlength="3"
                           class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                           placeholder="e.g., 123">
                </div>
                <div>
                    <label for="dlc" class="block text-sm font-medium text-gray-700">DLC (0-8):</label>
                    <input type="number" id="dlc" value="8" min="0" max="8"
                           class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                </div>
                <div>
                    <label for="data" class="block text-sm font-medium text-gray-700">Data (Hex, max 16 chars):</label>
                    <input type="text" id="data" value="ABCDEF0123456789" maxlength="16"
                           class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                           placeholder="e.g., AABBCCDD">
                </div>
                <div class="flex items-center">
                    <input type="checkbox" id="representationToggle" checked
                           class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                    <label for="representationToggle" class="ml-2 block text-sm text-gray-900">
                        Dominant = 1, Recessive = 0
                    </label>
                </div>
                <button id="generateBtn"
                        class="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    Generate Pattern
                </button>
            </div>

            <!-- Legend Section -->
            <div class="space-y-4">
                <h2 class="text-xl font-semibold text-gray-800">Legend:</h2>
                <div class="legend-item">
                    <div class="legend-color-box dominant"></div>
                    <span>Dominant Bit (Blue)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color-box recessive"></div>
                    <span>Recessive Bit (Gray)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color-box bg-white stuff-bit"></div>
                    <span>Stuff Bit (Red Box)</span>
                </div>
                <p class="text-sm text-gray-600 mt-4">
                    The CAN Bit Pattern includes Start of Frame (SOF), Arbitration Field (ID + RTR + IDE + r0), Control Field (DLC), Data Field, CRC Field, ACK Field, End of Frame (EOF), and Interframe Space (IFS).
                </p>
            </div>
        </div>

        <!-- Output Section -->
        <div>
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Generated Bit Pattern:</h2>
            <div id="output" class="bg-gray-50 p-4 rounded-md border border-gray-200 overflow-x-auto">
                <!-- Bit pattern will be displayed here -->
                <p class="text-gray-500">Enter CAN details and click "Generate Pattern".</p>
            </div>
            <div id="errorMessage" class="text-red-600 mt-4 font-medium hidden"></div>
        </div>
    </div>

    <script>
        // Constants for CAN frame
        const SOF = '0'; // Dominant
        const RTR_DATA_FRAME = '0'; // Dominant for data frame
        const IDE_STANDARD_CAN = '0'; // Dominant for standard CAN (11-bit ID)
        const R0 = '0'; // Recessive
        const CRC_DELIMITER = '1'; // Recessive
        const ACK_SLOT = '1'; // Recessive (filled by receiver with Dominant if acknowledged)
        const ACK_DELIMITER = '1'; // Recessive
        const EOF_BITS = '1111111'; // 7 Recessive bits
        const IFS_BITS = '111'; // 3 Recessive bits

        // CRC-15-CAN polynomial (X^15 + X^14 + X^10 + X^8 + X^7 + X^4 + X^3 + 1)
        // Represented as 1100011001011011 (dropping the leading X^15 term as it's implicit)
        const CRC_POLYNOMIAL = 0x62CC; // 0110 0010 1100 1100 (15 bits, excluding MSB)
                                     // (MSB is implicit at X^15)

        // Helper function to convert hex to binary string with padding
        function hexToBin(hex, padLength) {
            let bin = parseInt(hex, 16).toString(2);
            return bin.padStart(padLength, '0');
        }

        // Helper function to convert a binary string to a decimal
        function binToDec(bin) {
            return parseInt(bin, 2);
        }

        /**
         * Calculates the CAN CRC-15.
         * The CRC calculation covers the SOF, Arbitration Field, Control Field, and Data Field.
         * @param {string} bitString The bit string (SOF to Data) for which to calculate CRC.
         * @returns {string} The 15-bit CRC as a binary string.
         */
        function calculateCRC(bitString) {
            let crcRegister = 0; // Initial CRC value is 0

            for (let i = 0; i < bitString.length; i++) {
                const bit = parseInt(bitString[i], 10);

                // Shift the CRC register left by 1
                crcRegister <<= 1;

                // XOR with the current message bit
                crcRegister ^= bit;

                // If the MSB (X^15 position) is 1, XOR with the polynomial
                // We need to check if the 16th bit (0-indexed 15) is set, which means it overflowed past 15 bits
                // The polynomial is 0x62CC (for X^14 to X^0 bits)
                if (crcRegister & 0x8000) { // Check if X^15 bit is set (0x8000 is 1000000000000000 in binary)
                    crcRegister ^= CRC_POLYNOMIAL; // XOR with the polynomial
                }
                // Ensure CRC register remains 15 bits by masking
                crcRegister &= 0x7FFF; // Mask to keep only the last 15 bits (0111111111111111)
            }

            // The final CRC is the value in the register
            return crcRegister.toString(2).padStart(15, '0');
        }

        /**
         * Applies bit stuffing to a given bit string.
         * A bit of opposite polarity is inserted after five consecutive bits of the same polarity.
         * Bit stuffing applies to SOF, Arbitration Field, Control Field, Data Field, and CRC Field.
         * @param {string} bitString The bit string to be stuffed.
         * @returns {Object} An object containing the stuffed bit string and an array of indices of stuff bits.
         */
        function applyBitStuffing(bitString) {
            if (!bitString) return { stuffedBits: '', stuffBitIndices: [] };

            let stuffedString = '';
            let consecutiveCount = 0;
            let lastBit = '';
            const stuffBitIndices = [];

            for (let i = 0; i < bitString.length; i++) {
                const currentBit = bitString[i];
                stuffedString += currentBit; // Always add the current bit

                if (i === 0) {
                    lastBit = currentBit;
                    consecutiveCount = 1;
                } else {
                    if (currentBit === lastBit) {
                        consecutiveCount++;
                    } else {
                        consecutiveCount = 1;
                        lastBit = currentBit;
                    }
                }

                // If 5 consecutive identical bits are found, insert a stuff bit
                if (consecutiveCount === 5) {
                    const stuffBit = (currentBit === '0' ? '1' : '0'); // Insert opposite bit
                    stuffedString += stuffBit;
                    stuffBitIndices.push(stuffedString.length - 1); // Record the index of the inserted stuff bit
                    consecutiveCount = 0; // Reset count after inserting stuff bit
                    // The 'lastBit' should remain the bit that caused the stuffing,
                    // as the next bit after the stuff bit continues the sequence.
                    // For example, 00000 (0) -> 00000 (0) [stuff 1]. If next is 0, it's 00000(0)[stuff 1]0.
                    // The count for the new '0' starts from 1.
                }
            }
            return { stuffedBits: stuffedString, stuffBitIndices: stuffBitIndices };
        }


        /**
         * Generates the full CAN bit pattern including CRC and bit stuffing.
         * @returns {void}
         */
        function generateCanBitPattern() {
            const canIdHex = document.getElementById('canId').value.trim();
            const dlc = parseInt(document.getElementById('dlc').value, 10);
            const dataHex = document.getElementById('data').value.trim();
            const outputDiv = document.getElementById('output');
            const errorMessageDiv = document.getElementById('errorMessage');
            const representationToggle = document.getElementById('representationToggle').checked; // true for 1=dom, 0=rec; false for 0=dom, 1=rec

            errorMessageDiv.textContent = '';
            errorMessageDiv.classList.add('hidden');
            outputDiv.innerHTML = '<p class="text-gray-500">Generating pattern...</p>';

            // 1. Input Validation
            if (!canIdHex) {
                errorMessageDiv.textContent = 'Please enter a CAN ID.';
                errorMessageDiv.classList.remove('hidden');
                outputDiv.innerHTML = '';
                return;
            }
            if (!/^[0-9A-Fa-f]+$/.test(canIdHex)) {
                errorMessageDiv.textContent = 'CAN ID must be a hexadecimal number.';
                errorMessageDiv.classList.remove('hidden');
                outputDiv.innerHTML = '';
                return;
            }
            if (canIdHex.length > 3 || hexToBin(canIdHex, 0).length > 11) {
                errorMessageDiv.textContent = 'CAN ID must be 11 bits (max 3 hex chars, e.g., 7FF).';
                errorMessageDiv.classList.remove('hidden');
                outputDiv.innerHTML = '';
                return;
            }
            if (isNaN(dlc) || dlc < 0 || dlc > 8) {
                errorMessageDiv.textContent = 'DLC must be a number between 0 and 8.';
                errorMessageDiv.classList.remove('hidden');
                outputDiv.innerHTML = '';
                return;
            }
            if (!/^[0-9A-Fa-f]*$/.test(dataHex)) {
                errorMessageDiv.textContent = 'Data must be a hexadecimal string.';
                errorMessageDiv.classList.remove('hidden');
                outputDiv.innerHTML = '';
                return;
            }
            const expectedDataLengthBits = dlc * 8;
            const actualDataLengthBits = dataHex.length * 4;
            if (actualDataLengthBits < expectedDataLengthBits) {
                 errorMessageDiv.textContent = `Data length (${dataHex.length} hex chars = ${actualDataLengthBits} bits) is less than required by DLC (${dlc} bytes = ${expectedDataLengthBits} bits). Please pad with zeros or adjust DLC.`;
                 errorMessageDiv.classList.remove('hidden');
                 outputDiv.innerHTML = '';
                 return;
            } else if (actualDataLengthBits > expectedDataLengthBits) {
                 errorMessageDiv.textContent = `Data length (${dataHex.length} hex chars = ${actualDataLengthBits} bits) is greater than required by DLC (${dlc} bytes = ${expectedDataLengthBits} bits). Please truncate or adjust DLC.`;
                 errorMessageDiv.classList.remove('hidden');
                 outputDiv.innerHTML = '';
                 return;
            }


            // 2. Convert Inputs to Binary
            const canIdBinary = hexToBin(canIdHex, 11); // 11-bit ID
            const dlcBinary = dlc.toString(2).padStart(4, '0'); // 4-bit DLC
            const dataBinary = dataHex.split('').map(c => hexToBin(c, 4)).join(''); // Convert each hex char to 4 bits

            // 3. Assemble Unstuffed Frame (up to data) for CRC Calculation
            // SOF (1 bit) + Arbitration Field (11-bit ID + RTR + IDE + r0) + Control Field (DLC) + Data Field
            let preCRCMsg = '';
            preCRCMsg += SOF;
            preCRCMsg += canIdBinary;
            preCRCMsg += RTR_DATA_FRAME;
            preCRCMsg += IDE_STANDARD_CAN;
            preCRCMsg += R0;
            preCRCMsg += dlcBinary;
            preCRCMsg += dataBinary; // This includes the actual data bits based on DLC

            // 4. Calculate CRC
            const crc = calculateCRC(preCRCMsg);

            // 5. Build Full Unstuffed Frame for Stuffing Application
            let unstuffedFrame = preCRCMsg; // SOF to Data Field
            unstuffedFrame += crc; // 15-bit CRC
            unstuffedFrame += CRC_DELIMITER; // 1 bit Recessive (unstuffed)
            unstuffedFrame += ACK_SLOT; // 1 bit Recessive (unstuffed)
            unstuffedFrame += ACK_DELIMITER; // 1 bit Recessive (unstuffed)

            // 6. Apply Bit Stuffing
            // Bit stuffing applies to SOF, Arbitration Field, Control Field, Data Field, and CRC Field.
            // It does NOT apply to CRC Delimiter, ACK Slot/Delimiter, EOF, IFS.
            const partToStuff = preCRCMsg + crc; // SOF up to CRC
            const { stuffedBits, stuffBitIndices } = applyBitStuffing(partToStuff);

            // 7. Assemble Final CAN Frame
            let finalCanFrame = stuffedBits; // Stuffed part
            finalCanFrame += CRC_DELIMITER;
            finalCanFrame += ACK_SLOT;
            finalCanFrame += ACK_DELIMITER;
            finalCanFrame += EOF_BITS;
            finalCanFrame += IFS_BITS;

            // 8. Display the Pattern
            outputDiv.innerHTML = ''; // Clear previous output

            // Function to render a bit string with colors and labels
            const renderBits = (bitString, label, isStuffedSection = false, currentStuffedIndices = []) => {
                if (!bitString) return;

                const fieldContainer = document.createElement('div');
                fieldContainer.className = 'mb-2';

                const fieldLabel = document.createElement('span');
                fieldLabel.className = 'field-label';
                fieldLabel.textContent = label + ':';
                fieldContainer.appendChild(fieldLabel);

                const bitsContainer = document.createElement('div');
                bitsContainer.className = 'bit-container';

                let bitCount = 0;
                for (let i = 0; i < bitString.length; i++) {
                    const bitChar = bitString[i];
                    const bitElement = document.createElement('span');
                    let displayValue = bitChar;
                    let isDominant = (bitChar === '0'); // CAN standard: 0 is dominant, 1 is recessive

                    // Apply representation toggle
                    if (representationToggle) {
                        // Dominant=1, Recessive=0 (default display for many systems)
                        displayValue = isDominant ? '1' : '0';
                    } else {
                        // Dominant=0, Recessive=1 (as per CAN spec for physical layer)
                        displayValue = bitChar;
                    }

                    bitElement.textContent = displayValue;
                    bitElement.classList.add('bit');

                    if (isDominant) {
                        bitElement.classList.add('dominant');
                    } else {
                        bitElement.classList.add('recessive');
                    }

                    // Check if this bit is a stuff bit
                    // The indices refer to the stuffedBits string, not the unstuffed.
                    if (isStuffedSection && currentStuffedIndices.includes(bitCount)) {
                        bitElement.classList.add('stuff-bit');
                    }
                    bitCount++;

                    bitsContainer.appendChild(bitElement);
                }
                fieldContainer.appendChild(bitsContainer);
                outputDiv.appendChild(fieldContainer);
            };

            let currentStuffedIndex = 0; // Tracks position in the stuffedBits array

            // Render SOF
            renderBits(SOF, 'SOF', true, stuffBitIndices.filter(idx => idx < SOF.length && idx >= currentStuffedIndex).map(idx => idx - currentStuffedIndex));
            currentStuffedIndex += SOF.length;

            // Render Arbitration Field
            const arbitrationFieldUnstuffed = canIdBinary + RTR_DATA_FRAME + IDE_STANDARD_CAN + R0;
            const arbitrationFieldStuffed = stuffedBits.substring(currentStuffedIndex, currentStuffedIndex + arbitrationFieldUnstuffed.length + stuffBitIndices.filter(idx => idx >= currentStuffedIndex && idx < currentStuffedIndex + arbitrationFieldUnstuffed.length).length); // Account for potential stuff bits in this section
            renderBits(arbitrationFieldStuffed, 'Arbitration ID (ID + RTR + IDE + r0)', true, stuffBitIndices.filter(idx => idx >= currentStuffedIndex && idx < currentStuffedIndex + arbitrationFieldUnstuffed.length + stuffBitIndices.filter(idx2 => idx2 < currentStuffedIndex + arbitrationFieldUnstuffed.length).length).map(idx => idx - currentStuffedIndex));
            currentStuffedIndex += arbitrationFieldStuffed.length;

            // Render Control Field (DLC)
            const controlFieldUnstuffed = dlcBinary;
            const controlFieldStuffed = stuffedBits.substring(currentStuffedIndex, currentStuffedIndex + controlFieldUnstuffed.length + stuffBitIndices.filter(idx => idx >= currentStuffedIndex && idx < currentStuffedIndex + controlFieldUnstuffed.length + stuffBitIndices.filter(idx2 => idx2 < currentStuffedIndex + controlFieldUnstuffed.length).length).length);
            renderBits(controlFieldStuffed, 'Control Field (DLC)', true, stuffBitIndices.filter(idx => idx >= currentStuffedIndex && idx < currentStuffedIndex + controlFieldUnstuffed.length + stuffBitIndices.filter(idx2 => idx2 < currentStuffedIndex + controlFieldUnstuffed.length).length).map(idx => idx - currentStuffedIndex));
            currentStuffedIndex += controlFieldStuffed.length;


            // Render Data Field
            const dataFieldUnstuffed = dataBinary;
            const dataFieldStuffed = stuffedBits.substring(currentStuffedIndex, currentStuffedIndex + dataFieldUnstuffed.length + stuffBitIndices.filter(idx => idx >= currentStuffedIndex && idx < currentStuffedIndex + dataFieldUnstuffed.length + stuffBitIndices.filter(idx2 => idx2 < currentStuffedIndex + dataFieldUnstuffed.length).length).length);
            renderBits(dataFieldStuffed, 'Data Field', true, stuffBitIndices.filter(idx => idx >= currentStuffedIndex && idx < currentStuffedIndex + dataFieldUnstuffed.length + stuffBitIndices.filter(idx2 => idx2 < currentStuffedIndex + dataFieldUnstuffed.length).length).map(idx => idx - currentStuffedIndex));
            currentStuffedIndex += dataFieldStuffed.length;


            // Render CRC Field
            const crcFieldUnstuffed = crc;
            const crcFieldStuffed = stuffedBits.substring(currentStuffedIndex, currentStuffedIndex + crcFieldUnstuffed.length + stuffBitIndices.filter(idx => idx >= currentStuffedIndex && idx < currentStuffedIndex + crcFieldUnstuffed.length + stuffBitIndices.filter(idx2 => idx2 < currentStuffedIndex + crcFieldUnstuffed.length).length).length);
            renderBits(crcFieldStuffed, 'CRC Field', true, stuffBitIndices.filter(idx => idx >= currentStuffedIndex && idx < currentStuffedIndex + crcFieldUnstuffed.length + stuffBitIndices.filter(idx2 => idx2 < currentStuffedIndex + crcFieldUnstuffed.length).length).map(idx => idx - currentStuffedIndex));
            currentStuffedIndex += crcFieldStuffed.length;

            // Render CRC Delimiter (not stuffed)
            renderBits(CRC_DELIMITER, 'CRC Delimiter', false, []);

            // Render ACK Field (not stuffed)
            renderBits(ACK_SLOT + ACK_DELIMITER, 'ACK Field (Slot + Delimiter)', false, []);

            // Render EOF (not stuffed)
            renderBits(EOF_BITS, 'EOF', false, []);

            // Render IFS (not stuffed)
            renderBits(IFS_BITS, 'IFS', false, []);
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('generateBtn').addEventListener('click', generateCanBitPattern);
            document.getElementById('representationToggle').addEventListener('change', generateCanBitPattern);
            // Generate pattern on initial load with default values
            generateCanBitPattern();
        });
    </script>
</body>
</html>
